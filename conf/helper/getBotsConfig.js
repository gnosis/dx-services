const assert = require('assert')

// -----------------------------------------------------------------------------
//    getBotsConfig
// -----------------------------------------------------------------------------
/*
 * @version 0.1.1
 * @see Last version in https://github.com/gnosis/dx-services/tree/master/conf/helper/getBotsConfig.js
 *
 */

/**
 * Bot setup details.
 * Defines some key information required to decide which bots should be created.
 *
 * @typedef BotSetup
 * @type {Object}
 *
 *
 * @property {string} [name] - Base name used by the bots. If not
 *  defined, the "tokenSymbol" will be used instead. Either "name" or
 *  "tokenSymbol" are required.
 * @property {string} [tokenSymbol] - When the setup is just for a
 *  single market A-WETH, we can define the "tokenSymbol" instead of the "name".
 *
 *
 * @param {boolean} [createBuyBot = false] Defines wether to create the buy bot
 *  or not
 * @param {Object} [buyRules] Defines the rules of the buy bot. By default the
 *  it buys 1/2 (50%) if price changes by -1% and 100% if price changes by -4%,
 *  but it can be overrided with this prop. *
 * @param {boolean} [checkEnoughBalanceToBuyAll = true] Notifies if the buy bot
 *  won't be able to buy all the sell volumme
 *
 * @param {boolean} [createSellBot = false] Defines wether to create the sell bot
 *  or not
 * @param {number} [minimumSellVolumeInUsd] Defines the value in USD that the
 *  sell bot will use as a reference. If not defined, it will use the minimun
 *  threshold specified in the DutchX smart contracts.
 *
 *
 * @property {string} operatorAddressIndex - Specify the 0-based
 *  index (of the addresses generated by the menmonic) for the operator being
 *  used for the setup. It should match "operatorAddress".
 * @property {number} operatorAddress - Specify operator being used
 *  for the setup. It should match "operatorAddressIndex".
 *
 *
 * @property {string} [safeAddress] Specifies the Gnosis Safe address.
 *   Only for Safe setup.
 * @property {SafeModuleType} [safeModuleType] Specifies the Gnosis
 *   Safe module type. "seller" if the bots only sell, or "complete" if the safe also
 *   buys (note that these are different module implementations, so you have to
 *   make sure this matches the "safeModuleAddress" you provide). Only for Safe
 *   setup.
 * @property {string} [safeModuleType] Specifies the Gnosis
 *   Safe module type. "seller" if the bots only sell, or "buyer" if the safe also
 *   buys (note that these are different module implementations, so you have to
 *   make sure this matches the "safeModuleAddress" you provide). Only for Safe
 *   setup.
 *
 *
 * @property {string} [uniswapArbitrageAddress] Specifies the Gnosis Safe address.
 *   Only for Safe setup.
 * @property {string} [uniswapExchangeAddress] Specifies the Gnosis Safe address.
 *   Only for Safe setup.
 *
 *
 * @property {string} [minimumAmountInUsdForToken = 5000] It will notify if the
 *  operator (or the safe if it's a Safe Setup) has tokens worth less than the
 *  specified value in USD
 * @property {string} [minimumAmountForEther = 0.7] It will notify if the
 *  operator has tokens worth less than the specified value in Ether
 * @property {string} [minimumAmountForOwl = 300] It will notify if the
 *  operator (or the safe if it's a Safe Setup) has less OWL than the specified
 *  value
 *
 * @property {string} [bigSellVolumeThresholdInUsd = 5000] It will notify if any
 *  market has an auction with a sell volume greater then this threshold.
 *
 *
 * @property {Object[]} [depositInactivityPeriods] Times in which the deposit
 * bot won't be doing any deposit. Used to allow some time windows for
 * withdrawing tokens
 * @property {string} [claimCronSchedule = '00  02,06,10,14,18,22  *  *  *'] Defines the claiming times in cron
 *  format. See https://crontab.guru/#0_02,06,10,14,18,22_*_*_*
 *
 */

/**
* Aditional accounts that need
*
* @typedef MonitorBalanceRule
* @type {Object}
*
* @property {string} name Base name used for the monitoring bots.
* @property {number} [address] Address being monitored. If can be specified if
* @property {string} [minimumAmountForEther = 0] Ether balance.
*  It will notify if the address has tokens worth less than the specified
*  value in Ether
* @property {string} [minimumAmountInUsdForToken = 0] DutchX token balance.
*  It will notify if the address has tokens worth less than the specified value
*  in USD (deposited in DutchX smart contracts)
* @property {string} [minimumAmountForOwl = 0] It will notify if the
*  operator (or the safe if it's a Safe Setup) has less OWL than the specified
*  value
* @property {string} [minimumAmountInUsdForTokenBalance = 0] ERC20 balance
*  It will notify if the address has tokens worth less than the specified value
*  in USD (in the regular ERC20 token balance)
*/

/**
 * Slack channels setup
 *
 * @typedef SlackChannels
 * @type {Object}
 * @property {string} [info] Channel where bots report their activity, i.e.
 *  sell orders, buy orders or deposits
 *
 * @property {string} [devops] Channel where bots report any alert, i.e. errors,
 *  or warnings about lack of funding.
 *
 * @property {string} [comms] Channel where bots report big sell volumes
 *
 */

/**
* Safe module type
* @typedef {"seller", "complete"} SafeModuleType
*/

/**
 * Generate the bot config out of the bot setup details.
 * This bot setup details would specify a list of configs that will be used to
 * decide wich bots are needed.
 *
 * @param {string} namePrefix Specifies a prefix that will be added to all bot's
 *  names. Useful for pre-pending version numbers or env info.
 * @param {BotSetup[]} botsSetup List of configs to be used for defining the bots
 * @param {MonitorBalanceRule[]} [aditionalBalanceBots = []] Defines wether to
 *  create the sell bot
* @param {Object} [slackChannels = {}] Defines then
 * aditionalBalanceBots,
  slackChannels
 *  or not
 *
 *
 * @returns {Object} The config of the bots
 */
function getBotsConfig ({
  namePrefix,
  botsSetup,
  aditionalMonitoringAccounts = [],
  slackChannels = {}
}) {
  assert(namePrefix, '"namePrefix" is mandatory')
  assert(botsSetup, '"botsSetup" is mandatory')
  assert(botsSetup.length > 0, '"botsSetup" must have at least one setup')

  const botsConfig = botsSetup.map(config => {
    const {
      name,
      tokenSymbol,
      markets
    } = config
    return {
      ...config,
      name: name || tokenSymbol,
      markets: markets || [{
        tokenA: 'WETH',
        tokenB: tokenSymbol
      }]
    }
  })

  const buyBotsConfig = botsConfig
    .filter(({ createBuyBot = false }) => createBuyBot)

  const sellBotsConfig = botsConfig
    .filter(({ createSellBot = false }) => createSellBot)

  const arbitrageBotsConfig = botsConfig
    .filter(config => !!config.uniswapArbitrageAddress || !!config.uniswapExchangeAddress)

  const safeBotsConfig = botsConfig
    .filter(config => !!config.safeAddress || !!config.safeModuleAddress)

  // Do some validations for the botsConfig
  botsConfig.forEach(({
    name,
    markets,
    operatorAddress,
    operatorAddressIndex
  }) => {
    assert(name, `The name is required for the bot config`)
    assert(markets, `The markets is required. Define Either "markets" or "tokenSymbol"`)
    assert(operatorAddress, `The operatorAddress is required for the bot config`)
    assert(operatorAddressIndex >= 0, `The operatorAddressIndex is required for the bot config`)
  })

  // Do some validation for the safe setup
  safeBotsConfig.forEach(({
    safeAddress,
    safeModuleAddress
  }) => {
    assert(safeAddress, `The safeAddress is required when defining a Gnosis Safe setup`)
    assert(safeModuleAddress, `The safeModuleAddress is required when defining a Gnosis Safe setup`)
  })

  // Do some validation for the arbitrage setup
  arbitrageBotsConfig.forEach(({
    tokenSymbol,
    uniswapArbitrageAddress,
    uniswapExchangeAddress
  }) => {
    assert(uniswapArbitrageAddress, `The ${tokenSymbol} safe, has a arbitrage setup, but "uniswapArbitrageAddress" is missing`)
    assert(uniswapExchangeAddress, `The ${tokenSymbol} safe, has a arbitrage setup, but "uniswapExchangeAddress" is missing`)
  })

  // Do some basic validations for aditionalMonitoringAccounts
  aditionalMonitoringAccounts.forEach(({
    name,
    address,
    addressForEther,
    addressForTokens
  }) => {
    assert(name, `The "name" is mandatory for the aditionalMonitoringAccounts`)
    assert(address || (addressForEther && addressForTokens), `Either the "address" or "addressForEther" "addressForTokens" are required for the aditionalMonitoringAccounts. Review: ${name}`)
  })

  const markets = botsConfig.reduce((acc, { markets = [] }) => {
    markets.forEach(marketAux => {
      const market = getOrderedMarket(marketAux)
      const existingMarket = hasMarket(acc, market)

      if (!existingMarket) {
        acc.push(market)
      }
    })

    return acc
  }, [])

  const marketsByBigSellvolumeThreshold = botsConfig.reduce((acc, config) => {
    const {
      markets = [],
      bigSellVolumeThresholdInUsd = 5000
    } = config

    const marketsForThreshold = acc[bigSellVolumeThresholdInUsd]
    const orderedMarket = markets.map(getOrderedMarket)
    if (marketsForThreshold) {
      const newMarkets = orderedMarket.filter(market => !hasMarket(marketsForThreshold, market))
      acc[bigSellVolumeThresholdInUsd] = marketsForThreshold.concat(newMarkets)
    } else {
      acc[bigSellVolumeThresholdInUsd] = orderedMarket
    }

    return acc
  }, {})

  // Watch events and notify the event bus
  //   - Other bots, like the sell bot depends on it
  const watchEventsBot = {
    name: namePrefix + ' Watch events bot',
    markets: markets,
    factory: 'src/bots/WatchEventsBot'
  }

  // Get the biggest operator index
  const maxOperatorAddressIndex = botsSetup.reduce((acc, { operatorAddressIndex }) => {
    if (operatorAddressIndex) {
      return Math.max(operatorAddressIndex + 1, acc)
    } else {
      return acc
    }
  }, 0)

  const web3Provider = {
    factory: 'src/helpers/web3Providers/HDWalletSafeProvider.js',
    numAddresses: Math.max(maxOperatorAddressIndex, botsSetup.length), // Generate the correct number of addresses
    safes: botsConfig.map(({
      operatorAddressIndex,
      operatorAddress,
      safeAddress,
      safeModuleType,
      safeModuleAddress
    }) => ({
      operatorAddressIndex,
      operatorAddress,
      safeAddress,
      safeModuleType,
      safeModuleAddress
    }))
  }

  /********************************************/
  /*  Define some re-usable config for bots
  /*********************************************/

  // Default buy rules
  const buyLiquidityRulesDefault = [{
    // Buy 1/2 (50%) if price changes by -1%
    marketPriceRatio: { numerator: 99, denominator: 100 },
    buyRatio: { numerator: 1, denominator: 2 }
  }, {
    // Buy the 100% if price changes by -4%
    marketPriceRatio: { numerator: 96, denominator: 100 },
    buyRatio: { numerator: 1, denominator: 1 }
  }]

  // Backup buy rules
  const buyLiquidityRulesBackup = [{
    // Buy the 100% if price changes by -10%
    marketPriceRatio: { numerator: 90, denominator: 100 },
    buyRatio: { numerator: 1, denominator: 1 }
  }]

  const notificationsInfo = slackChannels.info ? [{
    type: 'slack',
    channel: slackChannels.info
  }] : []

  const notificationsDevops = slackChannels.devops ? [{
    type: 'slack',
    channel: 'CAX7PRS0J'
  }] : []

  const NOTIFICATIONS_COMMS = [{
    type: 'slack',
    channel: 'CKE5NSTHN'
  }]

  const ONE_MINUTE = 60 * 1000 // 60s
  const FIVE_MINUTES = 5 * 60 * 1000 // 5min

  /********************************************/
  /*  Helper functions
  /*********************************************/
  function getTokensFromMarkets (markets) {
    return markets.reduce((acc, { tokenA, tokenB }) => {
      if (!acc.includes(tokenA)) {
        acc.push(tokenA)
      }

      if (!acc.includes(tokenB)) {
        acc.push(tokenB)
      }

      return acc
    }, [])
  }

  function getOrderedMarket ({ tokenA: tokenAuxA, tokenB: tokenAuxB }) {
    let tokenA, tokenB
    if (tokenAuxA < tokenAuxB) {
      tokenA = tokenAuxA
      tokenB = tokenAuxB
    } else {
      tokenA = tokenAuxB
      tokenB = tokenAuxA
    }

    return { tokenA, tokenB }
  }

  /********************************************/
  /*  Sell Bots
  /*********************************************/

  const sellBots = sellBotsConfig.map(({
    name,
    markets,
    operatorAddress,
    minimumSellVolumeInUsd,
    safeAddress
  }) => {
    return {
      name: namePrefix + ' Sell Bot: ' + name,
      factory: 'src/bots/SellLiquidityBot',
      minimumSellVolumeInUsd,
      markets,
      botAddress: safeAddress || operatorAddress,
      notifications: notificationsInfo,
      checkTimeInMilliseconds: ONE_MINUTE
    }
  })

  /********************************************/
  /*  Buy Bots
  /*********************************************/
  const buyBots = buyBotsConfig.reduce((acc, safe) => {
    const {
      name,
      markets,
      operatorAddress,
      safeAddress,
      buyRules
    } = safe

    const botAddress = safeAddress || operatorAddress

    // Add main bot
    acc.push({
      name: namePrefix + ' Buy Bot: ' + name,
      factory: 'src/bots/BuyLiquidityBot',
      markets,
      botAddress,
      rules: buyRules || buyLiquidityRulesDefault,
      notifications: notificationsInfo,
      checkTimeInMilliseconds: ONE_MINUTE
    })

    // Add backup bot
    acc.push({
      name: namePrefix + ' Backup Buy Bot: ' + name,
      factory: 'src/bots/BuyLiquidityBot',
      markets,
      botAddress,
      rules: buyRules || buyLiquidityRulesBackup,
      notifications: notificationsInfo,
      checkTimeInMilliseconds: ONE_MINUTE
    })

    return acc
  }, [])

  /*******************************************
    High Sell Volume bot:
        Notifies if there's a big sell volume (that cannot be bought)
  ********************************************/
  const highSellVolumeBotsAccountTheshold = Object
    .keys(marketsByBigSellvolumeThreshold)
    .map(bigSellVolumeThresholdInUsd => {
      return {
        name: namePrefix + ' Big sell volume: $' + bigSellVolumeThresholdInUsd,
        factory: 'src/bots/HighSellVolumeBot',
        markets: marketsByBigSellvolumeThreshold[bigSellVolumeThresholdInUsd],
        thresholdInUsd: bigSellVolumeThresholdInUsd,
        notifications: NOTIFICATIONS_COMMS
      }
    })

  const highSellVolumeBotsAccount = buyBotsConfig
    .filter(({ checkEnoughBalanceToBuyAll = true }) => checkEnoughBalanceToBuyAll)
    .map(({
      name,
      markets,
      operatorAddress,
      safeAddress
    }) => {
      return {
        name: namePrefix + ' HighSellVolumeBot for BuyBot: ' + name,
        factory: 'src/bots/HighSellVolumeBot',
        markets,
        botAddress: safeAddress || operatorAddress,
        notifications: notificationsDevops
      }
    })

  /*******************************************
    Deposit bot:
        Monitor the account for new tokens
  ********************************************/

  const depositBots = botsConfig.map(({
    name,
    markets,
    operatorAddress,
    safeAddress,
    depositInactivityPeriods
  }) => {
    let botAddress, etherReserveAmount
    if (safeAddress) {
      botAddress = safeAddress
      etherReserveAmount = 0 // 0 Ether (deposit all)
    } else {
      botAddress = operatorAddress
      etherReserveAmount = 2 // 2 Ether (leave some Ether for gas)
    }

    return {
      name: namePrefix + ' Deposit bot: ' + name,
      factory: 'src/bots/DepositBot',
      tokens: getTokensFromMarkets(markets),
      botAddress,
      notifications: notificationsInfo,
      // You can use this to have some time to manually withdraw funds
      inactivityPeriods: depositInactivityPeriods || [
        { from: '10:00', to: '10:30' },
        { from: '11:30', to: '12:00' },
        { from: '15:30', to: '16:00' },
        { from: '18:30', to: '19:00' }
      ],
      checkTimeInMilliseconds: FIVE_MINUTES,
      etherReserveAmount
    }
  })

  /*******************************************
    Claim bot:
        Claim back tokens periodically
  ********************************************/

  // Claim bots
  const claimBots = botsConfig.map(({
    name,
    markets,
    operatorAddress,
    safeAddress,
    claimCronSchedule
  }) => {
    return {
      name: namePrefix + ' Claim bot: ' + name,
      factory: 'src/bots/ClaimBot',
      markets,
      botAddress: safeAddress || operatorAddress,
      cronSchedule: claimCronSchedule || '00  02,06,10,14,18,22  *  *  *', // Claim schedule. See https://crontab.guru/#0_02,06,10,14,18,22_*_*_*
      autoClaimAuctions: 90, // Number of auctions to look back
      notifications: notificationsInfo
    }
  })

  // Claim bots for arbitraje contracts
  const arbitrageClaimBots = arbitrageBotsConfig.map(({
    name,
    markets,
    operatorAddress,
    uniswapArbitrageAddress,
    claimCronSchedule
  }) => {
    return {
      name: namePrefix + ' Arbitrage claim bot: ' + name,
      factory: 'src/bots/ClaimBot',
      markets,
      claimAddress: uniswapArbitrageAddress,
      botAddress: operatorAddress,
      cronSchedule: claimCronSchedule || '00  01,09,17  *  *  *', // Claim schedule. See https://crontab.guru/#0_02,06,10,14,18,22_*_*_*
      autoClaimAuctions: 90, // Number of auctions to look back
      notifications: notificationsInfo
    }
  })

  /********************************************/
  /*  Arbitrage Bot
  /*********************************************/

  const arbitrageBots = arbitrageBotsConfig.map(({
    tokenSymbol,
    markets,
    operatorAddress,
    uniswapArbitrageAddress
  }) => {
    return {
      name: `${namePrefix} Arbitrage bot: ${tokenSymbol}-WETH`,
      factory: 'src/bots/ArbitrageBot',
      botAddress: operatorAddress,
      markets,
      arbitrageContractAddress: uniswapArbitrageAddress,
      minimumProfitInUsd: 5, // 5$
      notifications: notificationsInfo
    }
  })

  /********************************************/
  /*  Balance Bot
  /*********************************************/

  // Monitor operators Ether for gas and Safes tokens (WETH + Token)
  const mainBalanceBots = botsConfig.map(({
    name,
    markets,
    safeAddress,
    minimumAmountInUsdForToken: minimumAmountInUsdForTokenAux,
    minimumAmountForEther = 0.7,
    minimumAmountForOwl = 300,
    operatorAddress
  }) => {
    let botName, minimumAmountInUsdForToken
    if (safeAddress) {
      botName = `${namePrefix} Balance bot: ${name} Operator`
      minimumAmountInUsdForToken = 0 // With the Safe setup, the operator has only Ether (tokens are in the Safe)
    } else {
      botName = `${namePrefix} Balance bot: ${name}`
      minimumAmountInUsdForToken = minimumAmountInUsdForTokenAux || 5000
    }

    return {
      name: botName,
      factory: 'src/bots/BalanceCheckBot',
      tokens: getTokensFromMarkets(markets),
      botAddress: operatorAddress,
      notifications: notificationsDevops,
      minimumAmountForEther, // Ether balance
      minimumAmountInUsdForToken, // Balance in DutchX
      minimumAmountInUsdForTokenBalance: 0, // ERC20 balance
      minimumAmountForOwl // OWL
    }
  })

  const safeBalanceBots = safeBotsConfig.map(({
    name,
    markets,
    safeAddress,
    minimumAmountInUsdForToken = 5000,
    minimumAmountForOwl = 300
  }) => {
    return {
      name: `${namePrefix} Balance bot: ${name} Safe`,
      factory: 'src/bots/BalanceCheckBot',
      tokens: getTokensFromMarkets(markets),
      botAddress: safeAddress,
      notifications: notificationsDevops,
      minimumAmountForEther: 0, // Ether balance
      minimumAmountInUsdForToken, // Balance in DutchX
      minimumAmountInUsdForTokenBalance: 0, // ERC20 balance
      minimumAmountForOwl // OWL
    }
  })

  // Monitor the WETH balance in DutchX for the arbitrage contract
  const arbitrageContractBalanceBots = arbitrageBotsConfig.map(({
    name,
    uniswapArbitrageAddress
  }) => {
    return {
      name: `${namePrefix} Balance bot: ${name} Arbitrage`,
      factory: 'src/bots/BalanceCheckBot',
      tokens: ['WETH'],
      botAddress: uniswapArbitrageAddress,
      notifications: notificationsDevops,
      minimumAmountForEther: 0, // Ether balance
      minimumAmountInUsdForToken: 100, // Balance in DutchX
      minimumAmountInUsdForTokenBalance: 0, // ERC20 balance
      minimumAmountForOwl: 150 // OWL
    }
  })

  // Monitors the Uniswap Exchange Reserves (Ether and Token)
  const uniswapExchangeReservesBalanceBots = arbitrageBotsConfig.map(({
    tokenSymbol,
    uniswapExchangeAddress
  }) => {
    return {
      name: `${namePrefix} Balance bot: ${tokenSymbol} Uniswap Exchange`,
      factory: 'src/bots/BalanceCheckBot',
      tokens: [tokenSymbol],
      botAddress: uniswapExchangeAddress,
      notifications: notificationsDevops,
      minimumAmountForEther: 20, // Balance in DutchX.  20 Ether ≈ 3.000$ (TODO: Allow to specify in USD the Ether too)
      minimumAmountInUsdForToken: 0, // Balance in DutchX
      minimumAmountInUsdForTokenBalance: 3000, // ERC20 balance
      minimumAmountForOwl: 0
    }
  })

  // Aditional accounts being montitored
  const aditionalBalanceBots = aditionalMonitoringAccounts.map(({
    name,
    address,
    addressForEther,
    addressForTokens,
    minimumAmountForEther = 0,
    minimumAmountInUsdForToken = 0,
    minimumAmountInUsdForTokenBalance = 0,
    minimumAmountForOwl = 0
  }) => {
    return {
      name: namePrefix + ' ' + name,
      factory: 'src/bots/BalanceCheckBot',
      tokens: [],
      botAddress: address,
      botAddressForEther: addressForEther,
      botAddressForTokens: addressForTokens,
      notifications: notificationsDevops,
      minimumAmountForEther, // Balance in DutchX
      minimumAmountInUsdForToken, // Balance in DutchX
      minimumAmountInUsdForTokenBalance, // ERC20 balance
      minimumAmountForOwl // OWL balance
    }
  })

  /*******************************************
    Helper bots (watch event bots)
  ********************************************/

  function hasMarket (markets, { tokenA, tokenB }) {
    return markets.some(market => {
      return market.tokenA === tokenA &&
        market === tokenB
    })
  }

  /**************************************************************/
  /*  Price Repo: Strategies to get the price for the buy bot
  /**************************************************************/
  const priceRepo = {
    factory: 'src/repositories/PriceRepo/PriceRepoImpl',
    priceFeedStrategiesDefault: {
      strategy: 'sequence',
      feeds: ['binance', 'huobi', 'kraken', 'bitfinex', 'idex', 'hitbtc', 'liquid']
    },
    priceFeedStrategies: {
      'WETH-OMG': {
        strategy: 'sequence',
        feeds: ['binance', 'huobi', 'bitfinex']
      },
      'WETH-RDN': {
        strategy: 'sequence',
        feeds: ['huobi', 'binance', 'bitfinex']
      },
      'DAI-MKR': {
        strategy: 'sequence',
        feeds: ['hitbtc', 'bitfinex']
      },
      'WETH-DAI': {
        strategy: 'sequence',
        feeds: ['hitbtc', 'bitfinex']
      },
      'WETH-MKR': {
        strategy: 'sequence',
        feeds: ['hitbtc', 'bitfinex']
      },
      'WETH-GEN': {
        strategy: 'sequence',
        feeds: ['idex', 'liquid']
      },
      'WETH-GNO': {
        strategy: 'sequence',
        feeds: ['kraken', 'hitbtc']
      }
    },
    priceFeeds: {
      binance: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoBinance'
      },
      huobi: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoHuobi'
      },
      kraken: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoKraken',
        url: 'https://api.kraken.com',
        version: '0'
      },
      bitfinex: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoBitfinex'
      },
      idex: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoIdex'
      },
      hitbtc: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoHitbtc'
      },
      liquid: {
        factory: 'src/repositories/PriceRepo/feeds/PriceRepoLiquid'
      }
    },
    strategies: {
      sequence: {
        factory: 'src/repositories/PriceRepo/strategies/sequence'
      }
    }
  }

  return {
    WEB3_PROVIDER: web3Provider,
    MARKETS: markets,
    PRICE_REPO: priceRepo,
    SAFES: arbitrageBotsConfig,
    BOTS: [watchEventsBot]
    // .concat(highSellVolumeBotsAccountTheshold)

      // Sell bots
      .concat(sellBots)
      // Buy bot + detect high vol + arbitrage
      .concat(buyBots)
      .concat(highSellVolumeBotsAccountTheshold)
      .concat(highSellVolumeBotsAccount)
      .concat(arbitrageBots)
      // Deposit and claim
      .concat(depositBots)
      .concat(claimBots)
      .concat(arbitrageClaimBots)
      // Balance bots
      .concat(mainBalanceBots)
      .concat(safeBalanceBots)
      .concat(arbitrageContractBalanceBots)
      .concat(aditionalBalanceBots)
      .concat(uniswapExchangeReservesBalanceBots)
      .concat(aditionalMonitoringAccounts)
  }
}

module.exports = getBotsConfig
